.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "deb-src-symbols 5"
.TH deb-src-symbols 5 "2020-08-02" "1.20.5" "dpkg suite"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "BEZEICHNUNG"
.IX Header "BEZEICHNUNG"
deb-symbols \- Debians erweiterte Vorlagendatei f\(:ur Laufzeitbibliotheken
.SH "\(:UBERSICHT"
.IX Header "\(:UBERSICHT"
\&\fBdebian/\fR\fIPaket\fR\fB.symbols.\fR\fIArch\fR, \fBdebian/symbols.\fR\fIArch\fR,
\&\fBdebian/\fR\fIPaket\fR\fB.symbols\fR, \fBdebian/symbols\fR
.SH "BESCHREIBUNG"
.IX Header "BESCHREIBUNG"
Die Symboldateivorlagen werden in Debian-Quellpaketen ausgeliefert. Deren
Format ist eine Obermenge der in Bin\(:arpaketen ausgelieferten Symboldateien.
.SS "Kommentare"
.IX Subsection "Kommentare"
In Symboldateien werden Kommentare unterst\(:utzt. Jede Zeile, die mit \(bq#\(cq als
erstem Zeichen beginnt, ist ein Kommentar, falls sie nicht mit \(bq#include\(cq
beginnt (siehe Abschnitt \fBIncludes verwenden\fR). Zeilen, die mit \(bq#MISSING:\(cq
anfangen, sind besondere Kommentare, die verschwundene Symbole
dokumentieren.
.SS "Verwendung der #PACKAGE#\-Ersetzung"
.IX Subsection "Verwendung der #PACKAGE#-Ersetzung"
In einigen seltenen F\(:allen sind die Namen der Bibliotheken nicht auf allen
Architekturen gleich. Um zu vermeiden, dass der Paketname in der Symboldatei
fest kodiert wird, k\(:onnen Sie die Markierung \fI#PACKAGE#\fR verwenden. W\(:ahrend
der Installation der Symboldatei wird sie durch den echten Paketnamen
ersetzt. Anders als die Markierung \fI#MINVER#\fR wird \fI#PACKAGE#\fR nie in der
Symboldatei innerhalb eines Bin\(:arpakets auftauchen.
.SS "Verwendung von Symbolkennzeichnungen"
.IX Subsection "Verwendung von Symbolkennzeichnungen"
Symbolkennzeichnungen sind n\(:utzlich, um Symbole zu markieren, die in
irgendeiner Weise besonders sind. Jedes Symbol kann eine beliebige Anzahl
zugeordneter Kennzeichnungen besitzen. W\(:ahrend alle Kennzeichnungen
ausgewertet und gespeichert werden, werden nur einige von \fBdpkg-gensymbols\fR
verstanden und l\(:osen eine Spezialbehandlung der Symbole aus. Lesen Sie den
Unterabschnitt \fBStandardsymbolkennzeichnungen\fR f\(:ur eine Referenz dieser
Kennzeichnungen.
.PP
Kennzeichnungsspezifikationen kommen direkt vor dem Symbolnamen (dazwischen
sind keine Leerraumzeichen erlaubt). Sie beginnen immer mit einer \(:offnenden
Klammer \fB(\fR, enden mit einer schlie\(ssenden Klammer \fB)\fR und m\(:ussen
mindestens eine Kennzeichnung enthalten. Mehrere Kennzeichnungen werden
durch das Zeichen \fB|\fR getrennt. Jede der Kennzeichnungen kann optional
einen Wert enthalten, der von der Kennzeichnung durch das Zeichen \fB=\fR
getrennt wird. Kennzeichennamen und \-werte k\(:onnen beliebige Zeichenketten
sein, sie d\(:urfen allerdings keine der der besonderen Zeichen \fB)\fR \fB|\fR \fB=\fR
enthalten. Symbolnamen, die einer Kennzeichnungsspezifikation folgen, k\(:onnen
optional mit den Zeichen \fB'\fR oder \fB"\fR zitiert werden, um Leerraumzeichen
darin zu erlauben. Falls keine Kennzeichnungen f\(:ur das Symbol spezifiziert
sind, werden Anf\(:uhrungszeichen als Teil des Symbolnamens behandelt, der bis
zum ersten Leerzeichen geht.
.PP
.Vb 9
\&  (Kennz1=bin markiert|Name mit Leerraum)"zitiertes gekennz Symbol"@Base 1.0
\&  (optional)gekennzeichnet_unzitiertes_Symbol@Base 1.0 1
\&  ungekennzeichnetes_Symbol@Base 1.0
\&Das erste Symbol im Beispiel hei\(sst I<zitiertes gekennz Symbol> und hat zwei
\&Kennzeichnungen: I<Kennz1> mit dem Wert I<bin markiert> und I<Name mit
\&Leerraum> ohne Wert. Das zweite Symbol hei\(sst
\&I<gekennzeichnet_unzitiertes_Symbol> und ist nur mit dem Kennzeichen namens
\&I<optional> gekennzeichnet. Das letzte Symbol ist ein Beispiel eines
\&normalen, nicht gekennzeichneten Symbols.
.Ve
.PP
Da Symbolkennzeichnungen eine Erweiterung des Formats \fBdeb-symbols\fR(5)
sind, k\(:onnen sie nur Teil der in Quellpaketen verwandten Symboldateien sein
(diese Dateien sollten dann als Vorlagen zum Bau der Symboldateien, die in
Bin\(:arpakete eingebettet werden, gesehen werden). Wenn \fBdpkg-gensymbols\fR
ohne die Option \fB\-t\fR aufgerufen wird, wird es alle Symbole ausgeben, die
zum Format \fBdeb-symbols\fR(5) kompatibel sind: Es verarbeitet die Symbole
entsprechend der Anforderungen ihrer Standardkennzeichnungen und entfernt
alle Kennzeichnungen aus der Ausgabe. Im Gegensatz dazu werden alle Symbole
und ihre Kennzeichnungen (sowohl die Standardkennzeichnungen als auch die
unbekannten) im Vorlagenmodus (\fB\-t\fR) in der Ausgabe beibehalten und in
ihrer Originalform, wie sie geladen wurden, auch geschrieben.
.SS "Standard-Symbolkennzeichnungen"
.IX Subsection "Standard-Symbolkennzeichnungen"
.IP "\fBoptional\fR" 4
.IX Item "optional"
Ein als \(Bqoptional\(lq gekennzeichnetes Symbol kann jederzeit von der Bibliothek
verschwinden und wird nie zum Fehlschlag von \fBdpkg-gensymbols\fR
f\(:uhren. Verschwundene optionale Symbole werden kontinuierlich als \s-1MISSING\s0
(Fehlend) in dem Diff in jeder neuen Paketversion auftauchen. Dieses
Verhalten dient als Erinnerung f\(:ur den Betreuer, dass so ein Symbol aus der
Symboldatei entfernt oder wieder der Bibliothek hinzugef\(:ugt werden
muss. Wenn das optionale Symbol, das bisher als \s-1MISSING\s0 angegeben gewesen
war, pl\(:otzlich in der n\(:achsten Version wieder auftaucht, wird es wieder auf
den Status \(Bqexisting\(lq (existierend) gebracht, wobei die minimale Version
unver\(:andert bleibt.
.Sp
Diese Markierung ist f\(:ur private Symbole n\(:utzlich, deren Verschwinden keinen
ABI-Bruch ausl\(:ost. Beispielsweise fallen die meisten
\&\*(C+\-Template\-Instanziierungen in diese Kategorie. Wie jede andere Markierung
kann auch diese einen beliebigen Wert haben: sie k\(:onnte angeben, warum
dieses Symbol als optional betrachtet wird.
.IP "\fBarch=\fR\fIArchitekturliste\fR" 4
.IX Item "arch=Architekturliste"
.PD 0
.IP "\fBarch\-bits=\fR\fIArchitektur-Bits\fR" 4
.IX Item "arch-bits=Architektur-Bits"
.IP "\fBarch\-endian=\fR\fIArchitektur-Bytereihenfolge\fR" 4
.IX Item "arch-endian=Architektur-Bytereihenfolge"
.PD
Diese Markierungen erlauben es, den Satz an Architekturen einzugrenzen, auf
denen das Symbol existieren sollte. Die Markierungen \fBarch-bits\fR und
\&\fBarch-endian\fR werden seit Dpkg 1.18.0 unterst\(:utzt. Wenn die Symbolliste mit
den in der Bibliothek entdeckten Symbolen aktualisiert wird, werden alle
architekturspezifischen Symbole, die nicht auf die aktuelle Host-Architektur
passen, so behandelt, als ob sie nicht existierten. Falls ein
architekturspezifisches Symbol, das auf die aktuelle Host-Architektur passt,
in der Bibliothek nicht existiert, werden die normalen Regeln f\(:ur fehlende
Symbole angewandt und \fBdpkg-gensymbols\fR k\(:onnte dadurch fehlschlagen. Auf
der anderen Seite, falls das architekturspezifische Symbol gefunden wurde,
wenn es nicht existieren sollte (da die aktuelle Host-Architektur nicht in
der Markierung aufgef\(:uhrt ist oder nicht auf die Bytereihenfolge und Bits
passt), wird sie architekturneutral gemacht (d.h. die Architektur\-,
Architektur\-Bits\- und Architektur-Bytereihenfolgemarkierungen werden
entfernt und das Symbol wird im Diff aufgrund dieser \(:Anderung auftauchen),
aber es wird nicht als neu betrachtet.
.Sp
Beim Betrieb im standardm\(:a\(ssigen nicht-Vorlagen-Modus werden unter den
architekturspezifischen Symbolen nur die in die Symboldatei geschrieben, die
auf die aktuelle Host-Architektur passen. Auf der anderen Seite werden beim
Betrieb im Vorlagenmodus alle architekturspezifischen Symbole (darunter auch
die von fremden Architekturen) immer in die Symboldatei geschrieben.
.Sp
Das Format der \fIArchitekturliste\fR ist das gleiche wie das des Feldes
\&\fBBuild-Depends\fR in \fIdebian/control\fR (au\(sser den einschlie\(ssenden eckigen
Klammern []). Beispielsweise wird das erste Symbol aus der folgenden Liste
nur auf den Architekturen Alpha, Any\-amd64 und Ia64 betrachtet, das zweite
nur auf Linux-Architekturen, w\(:ahrend das dritte \(:uberall au\(sser auf Armel
betrachtet wird.
.Sp
.Vb 3
\&  (arch=alpha any\-amd64 ia64)64_Bit_spezifisches_Symbol@Base 1.0
\&  (arch=linux\-any)Linux_spezifisches_Symbol@Base 1.0
\&  (arch=!armel)Symbol_das_Armel_nicht_hat@Base 1.0
.Ve
.Sp
\&\fIArchitektur-Bits\fR ist entweder \fB32\fR oder \fB64\fR.
.Sp
.Vb 2
\&  (arch\-bits=32)32_Bit_spezifisches_Symbol@Base 1.0
\&  (arch\-bits=64)64_Bit_spezifisches_Symbol@Base 1.0
.Ve
.Sp
\&\fIArchitektur-Bytereihenfolge\fR ist entweder \fBlittle\fR oder \fBbig\fR.
.Sp
.Vb 2
\&  (arch\-endian=little)Little_Endian_spezifisches_Symbol@Base 1.0
\&  (arch\-endian=big)Big_Endian_spezifisches_Symbol@Base 1.0
.Ve
.Sp
Mehrere Einschr\(:ankungen k\(:onnen aneinandergeh\(:angt werden.
.Sp
.Vb 1
\&  (arch\-bits=32|arch\-endian=little)32_Bit_Le_Symbol@Base 1.0
.Ve
.IP "\fBallow-internal\fR" 4
.IX Item "allow-internal"
dpkg-gensymbols verf\(:ugt \(:uber eine interne Liste von Symbolen, die nicht in
Symboldateien auftauchen sollten, da sie normalerweise nur Seiteneffekte von
Implementierungsdetails in der Werkzeugkette darstellen (seit Dpkg
1.20.1). Falls Sie aus irgendeinem Grund wollen, dass diese Symbole in der
Symboldatei aufgenommen werden, sollten Sie das Symbol mit \fBallow-internal\fR
kennzeichnen. Dies kann f\(:ur einige grundlegende Bibliotheken der
Werkzeugkette wie \(Bqlibgcc\(lq notwendig sein.
.IP "\fBignore-blacklist\fR" 4
.IX Item "ignore-blacklist"
Ein veralteter Alias f\(:ur \fBallow-internal\fR (seit Dpkg 1.20.1, unterst\(:utzt
seit Dpkg 1.15.3).
.IP "\fBc++\fR" 4
.IX Item "c++"
Gibt \fIc++\fR\-Symbolmuster an. Lesen Sie den nachfolgenden Unterabschnitt
\&\fBVerwendung von Symbolmustern\fR.
.IP "\fBsymver\fR" 4
.IX Item "symver"
Gibt \fIsymver\fR (Symbolversion)\-Symbolmuster an. Lesen Sie den nachfolgenden
Unterabschnitt \fBVerwendung von Symbolmustern\fR.
.IP "\fBregex\fR" 4
.IX Item "regex"
Gibt \fIregex\fR\-Symbolmuster an. Lesen Sie den nachfolgenden Unterabschnitt
\&\fBVerwendung von Symbolmustern\fR.
.SS "Verwendung von Symbolmustern"
.IX Subsection "Verwendung von Symbolmustern"
Anders als die Standardsymbolspezifikation kann ein Muster mehrere reale
Symbole aus der Bibliothek abdecken. \fBdpkg-gensymbols\fR wird versuchen,
jedes Muster auf jedes reale Symbol, f\(:ur das \fIkein\fR spezifisches
Symbolgegenst\(:uck in der Symboldatei definiert ist, abzugleichen. Wann immer
das erste passende Muster gefunden wurde, werden alle Kennzeichnungen und
Eigenschaften als Basisspezifikation des Symbols verwandt. Falls keines der
Muster passt, wird das Symbol als neu betrachtet.
.PP
Ein Muster wird als verloren betrachtet, falls es auf kein Symbol in der
Bibliothek passt. Standardm\(:a\(ssig wird dies ein Versagen von
\&\fBdpkg-gensymbols\fR in der Stufe \fB\-c1\fR oder h\(:oher ausl\(:osen. Falls der
Fehlschlag allerdings unerw\(:unscht ist, kann das Muster mit der Kennzeichnung
\&\fIoptional\fR markiert werden. Falls das Muster dann auf nichts passt, wird es
im Diff nur als \s-1MISSING\s0 (fehlend) auftauchen. Desweiteren kann das Muster
wie jedes Symbol auf die spezielle Architektur mit der Kennzeichnung \fIarch\fR
beschr\(:ankt werden. Bitte lesen Sie den Unterabschnitt
\&\fBStandard-Symbolkennzeichnungen\fR oben f\(:ur weitere Informationen.
.PP
Muster sind eine Erweiterung des Formats \fBdeb-symbols\fR(5); sie sind daher
nur in Symboldatei-Vorlagen g\(:ultig. Die Musterspezifikationssyntax
unterscheidet sich nicht von der eines spezifischen Symbols. Allerdings
dient der Symbolnamenteil der Spezifikation als Ausdruck, der gegen
\&\fIName@Version\fR eines realen Symbols abgeglichen wird. Um zwischen den
verschiedenen Mustertypen zu unterscheiden, wird es typischerweise mit einer
speziellen Kennzeichnung gekennzeichnet.
.PP
Derzeit unterst\(:utzt \fBdpkg-gensymbols\fR drei grundlegene Mustertypen:
.IP "\fBc++\fR" 4
.IX Item "c++"
Dieses Muster wird durch die Kennzeichnung \fIc++\fR verzeichnet. Es passt nur
auf die entworrenen (\(Bqdemangled\(lq) Symbolnamen (wie sie vom Hilfswerkzeug
\&\fBc++filt\fR(1) ausgegeben werden). Dieses Muster ist sehr hilfreich, um auf
Symbole zu passen, bei dem die verworrenen (\(Bqmangled\(lq) Namen sich auf
verschiedenen Architekturen unterscheiden w\(:ahrend die entworrenen die
gleichen bleiben. Eine Gruppe solcher Symbole ist \fInon-virtual thunks\fR, die
einen architekturspezifischen Versatz in ihren verworrenen Namen eingebettet
haben. Eine h\(:aufige Instanz dieses Falles ist ein virtueller Destruktor, der
unter rautenf\(:ormiger Vererbung ein nicht-virtuelles Thunk-Symbol
ben\(:otigt. Selbst wenn beispielsweise _ZThn8_N3NSB6ClassDD1Ev@Base auf 32
Bit-Architekturen _ZThn16_N3NSB6ClassDD1Ev@Base auf 64 Bit-Architekturen
ist, kann es mit einem einzigen \fIc++\fR\-Muster abgeglichen werden:
.Sp
.Vb 4
\& libdummy.so.1 libdummy1 #MINVER#
\&  […]
\&  (c++)"non\-virtual thunk to NSB::ClassD::~ClassD()@Base" 1.0
\&  […]
.Ve
.Sp
Der entworrene Name oben kann durch Ausf\(:uhrung folgenden Befehls erhalten
werden:
.Sp
.Vb 1
\&  $ echo \*(Aq_ZThn8_N3NSB6ClassDD1Ev@Base\*(Aq | c++filt
.Ve
.Sp
Bitte beachten Sie, dass per Definition zwar der verworrene Name in der
Bibliothek eindeutig ist, die aber nicht notwendigerweise f\(:ur die
entworrenen Namen zutrifft. Ein Satz von unterschiedlichen realen Symbolen
k\(:onnen den gleichen entworrenen Namen haben. Beispielsweise ist das der Fall
bei nicht-virtuellen Thunk-Symbolen in komplexen Vererbungskonfigurationen
oder bei den meisten Konstruktoren und Destruktoren (da g++ typischerweise
zwei reale Symbole f\(:ur sie generiert). Da diese Kollisionen aber auf dem
ABI-Niveau passieren, sollten sie nicht die Qualit\(:at der Symboldatei
reduzieren.
.IP "\fBsymver\fR" 4
.IX Item "symver"
Dieses Muster wird durch die Kennzeichnung \fIsymver\fR verzeichnet. Gut
betreute Bibliotheken verf\(:ugen \(:uber versionierte Symbole, wobei jede Version
zu der Version der Originalautoren passt, in der dieses Symbol hinzugef\(:ugt
wurde. Falls das der Fall ist, k\(:onnen Sie ein \fIsymver\fR\-Muster verwenden,
das auf jedes zu einer spezifizierten Version zugeh\(:orige Symbol
passt. Beispiel:
.Sp
.Vb 5
\& libc.so.6 libc6 #MINVER#
\&  (symver)GLIBC_2.0 2.0
\&  […]
\&  (symver)GLIBC_2.7 2.7
\&  access@GLIBC_2.0 2.2
.Ve
.Sp
Alle den Versionen \s-1GLIBC_2.0\s0 und \s-1GLIBC_2.7\s0 zugeordneten Symbole werden zu
einer minimalen Version 2.0 bzw. 2.7 f\(:uhren, wobei das Symbol
access@GLIBC_2.0 die Ausnahme darstellt. Es wird zu einer minimalen
Abh\(:angigkeit auf libc6 Version 2.2 f\(:uhren, obwohl es im Geltungsbereich des
Musters \(Bq(symver)GLIBC_2.0\(lq geh\(:ort, da spezielle Symbole vor Mustern Vorrang
haben.
.Sp
Bitte beachten Sie, dass Platzhaltermuster im alten Format (angezeigt durch
\(Bq*@version\(lq im Symbolnamenfeld) zwar noch unterst\(:utzt werden, sie aber durch
die Syntax im neuen Format \(Bq(symver|optional)version\(lq abgel\(:ost
wurden. Beispielsweise sollte \(Bq*@GLIBC_2.0 2.0\(lq als
\(Bq(symver|optional)GLIBC_2.0 2.0\(lq geschrieben werden, falls das gleiche
Verhalten ben\(:otigt wird.
.IP "\fBregex\fR" 4
.IX Item "regex"
Muster mit regul\(:aren Ausdr\(:ucken werden durch die Kennzeichnung \fIregex\fR
verzeichnet. Sie passen auf den regul\(:aren Ausdruck von Perl, der im
Symbolnamenfeld angegeben ist. Ein regul\(:arer Ausdruck wird wie er ist
abgeglichen. Denken Sie daher daran, ihn mit dem Zeichen \fI^\fR zu beginnen,
da er ansonsten auf jeden Teil der Zeichenkette des realen Symbols
\&\fIname@version\fR passt. Beispiel:
.Sp
.Vb 3
\& libdummy.so.1 libdummy1 #MINVER#
\&  (regex)"^mystack_.*@Base$" 1.0
\&  (regex|optional)"private" 1.0
.Ve
.Sp
Symbole wie \(Bqmystack_new@Base\(lq, \(Bqmystack_push@Base\(lq, \(Bqmystack_pop@Base\(lq
usw. passen auf das erste Muster, w\(:ahrend dies z.B. f\(:ur
\(Bqng_mystack_new@Base\(lq nicht der Fall ist. Das zweite Muster wird auf alle
Symbole, die die Zeichenkette \(Bqprivate\(lq in ihren Namen enthalten, passen und
die abgeglichenen Symbole erben die Kennzeichnung \fIoptional\fR vom Muster.
.PP
Die oben aufgef\(:uhrten grundlegenden Muster k\(:onnen \- wo es Sinn ergibt \-
kombiniert werden. In diesem Fall werden sie in der Reihenfolge verarbeitet,
in der die Kennzeichnungen angegeben sind. Im Beispiel
.PP
.Vb 2
\&  (c++|regex)"^NSA::ClassA::Private::privmethod\ed\e(int\e)@Base" 1.0
\&  (regex|c++)N3NSA6ClassA7Private11privmethod\edEi@Base 1.0
.Ve
.PP
werden die Symbole \(Bq_ZN3NSA6ClassA7Private11privmethod1Ei@Base\(lq und
\(Bq_ZN3NSA6ClassA7Private11privmethod2Ei@Base\(lq verglichen. Beim Vergleichen
des ersten Musters wird das rohe Symbol erst als \*(C+\-Symbol entworren, dann
wird der entworrene Name mit den regul\(:aren Ausdruck verglichen. Auf der
anderen Seite wird beim Vergleichen des zweiten Musters der regul\(:are
Ausdruck gegen den rohen Symbolnamen verglichen, dann wird das Symbol
\(:uberpr\(:uft, ob es ein \*(C+\-Symbol ist, indem das Entwirren versucht wird. Ein
Fehlschlag eines einfachen Musters wird zum Fehlschlag des gesamten Musters
f\(:uhren. Daher wird beispielsweise
\(Bq_\|_N3NSA6ClassA7Private11privmethod\edEi@Base\(lq auf keines der Muster passen,
da es kein g\(:ultiges \*(C+\-Symbol ist.
.PP
Im Allgemeinen werden die Muster in zwei Kategorien eingeteilt: Aliase
(grundlegende \fIc++\fR\- und \fIsymver\fR\-Muster) und generische Muster (\fIregex\fR
und alle Kombinationen grundlegender Muster). Abgleichen von grundlegenden
alias-basierenden Mustern ist schnell (O(1)), w\(:ahrend generische Muster O(N)
(wobei N die Anzahl der generischen Muster ist) f\(:ur jedes Symbol ist. Daher
wird empfohlen, generische Muster nicht zu viel zu verwenden.
.PP
Wenn mehrere Muster auf das gleiche Symbol passen, werden Aliase (zuerst
\&\fIc++\fR, dann \fIsymver\fR) gegen\(:uber den generischen Mustern
bevorzugt. Generische Muster werden in der Reihenfolge, in der sie in der
Symboldateivorlage gefunden werden, verglichen, bis zum ersten
Erfolg. Beachten Sie aber, dass das manuelle Anordnen der
Vorlagendateieintr\(:age nicht empfohlen wird, da \fBdpkg-gensymbols\fR Diffs
basierend auf der alphanumerischen Reihenfolge ihrer Namen erstellt.
.SS "Includes verwenden"
.IX Subsection "Includes verwenden"
Wenn der Satz der exportierten Symbole sich zwischen Architekturen
unterscheidet, kann es ineffizient werden, eine einzige Symboldatei zu
verwenden. In diesen F\(:allen kann sich eine Include-Direktive in einer Reihe
von Arten als n\(:utzlich erweisen:
.IP "\(bu" 4
Sie k\(:onnen den gemeinsamen Teil in eine externe Datei auslagern und diese
Datei dann in Ihre \fIPaket\fR.symbols.\fIArch\fR\-Datei mit einer
include-Direktive wie folgt einbinden:
.Sp
.Vb 1
\& #include "I<Pakete>.symbols.common"
.Ve
.IP "\(bu" 4
Die Include-Direktive kann auch wie jedes Symbol gekennzeichnet werden:
.Sp
.Vb 1
\& (Kennzeichen|…|KennzeichenN)#include "einzubindende\-Datei"
.Ve
.Sp
Als Ergebnis werden alle Symbole aus der \fIeinzubindende-Datei\fR
standardm\(:a\(ssig als mit \fIKennzeichen\fR … \fIKennzeichenN\fR gekennzeichnet
betrachtet. Sie k\(:onnen diese Funktionalit\(:at benutzen, um eine gemeinsame
Datei \fIPaket\fR.symbols zu erstellen, die architekturspezifische
Symboldateien einbindet:
.Sp
.Vb 4
\&  gemeinsames_Symbol1@Base 1.0
\& (arch=amd64 ia64 alpha)#include "Paket.symbols.64bit"
\& (arch=!amd64 !ia64 !alpha)#include "Paket.symbols.32bit"
\&  gemeinsames_Symbol2@Base 1.0
.Ve
.PP
Die Symboldateien werden Zeile f\(:ur Zeile gelesen und include-Direktiven
werden bearbeitet, sobald sie erkannt werden. Das bedeutet, dass der Inhalt
der mit include eingebundenen Datei jeden Inhalt \(:uberschreiben kann, der vor
der Include-Direktive aufgetaucht ist und Inhalt nach der Direktive alles
aus der eingebundenen Datei \(:uberschreiben kann. Jedes Symbol (oder sogar
weitere #include\-Direktiven) in der eingebundenen Datei kann zus\(:atzliche
Kennzeichnungen spezifizieren oder Werte der vererbten Kennzeichnungen in
ihrer Kennzeichnungsspezifikation \(:uberschreiben. Allerdings gibt es keine
M\(:oglichkeit f\(:ur ein Symbol, die ererbten Kennzeichnungen zu \(:uberschreiben.
.PP
Eine eingebundene Datei kann die Kopfzeile wiederholen, die den \s-1SONAME\s0 der
Bibliothek enth\(:alt. In diesem Fall \(:uberschreibt sie jede vorher gelesene
Kopfzeile. Allerdings ist es im Allgemeinen am besten, die Wiederholung von
Kopfzeilen zu vermeiden. Eine Art, dies zu erreichen, ist wie folgt:
.PP
.Vb 2
\& #include "libirgendwas1.symbols.common"
\&  arch_spezifisches_Symbol@Base 1.0
.Ve
.SH "SIEHE AUCH"
.IX Header "SIEHE AUCH"
\&\fBdeb-symbols\fR(5), \fBdpkg-shlibdeps\fR(1), \fBdpkg-gensymbols\fR(1).
.SH "\(:UBERSETZUNG"
.IX Header "\(:UBERSETZUNG"
Die deutsche \(:Ubersetzung wurde 2004, 2006\-2020 von Helge Kreutzmann
<debian@helgefjell.de>, 2007 von Florian Rehnisch <eixman@gmx.de> und
2008 von Sven Joachim <svenjoac@gmx.de>
angefertigt. Diese \(:Ubersetzung ist Freie Dokumentation; lesen Sie die
\&\s-1GNU\s0 General Public License Version 2 oder neuer f\(:ur die Kopierbedingungen.
Es gibt \s-1KEINE HAFTUNG.\s0
